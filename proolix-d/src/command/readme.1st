Proolix Development Kit - documentation
(C) Serge Pustovoitoff, 1994-1999

        1. Введение

        2. Программирование на С в Пруликсе

        3. Программирование на ассемблере в Пруликсе

        4. Адаптация программ на С для ОС Пруликс
           Что делать, если у вас нет Turbo C 2.0
           Как узнать, реализован ли данный системный вызов в Пруликсе



        1. Введение

    Hаконец-то  стало  возможным  написание  программ  специально для работы в
среде  Пруликса  ! C-компилятора, ни gcc под Пруликсом еще нет, поэтому вместо
трансляции  программ необходима КРОСС-ТРАHСЛЯЦИЯ, или иначе говоря, трансляция
на  другой  платформе,  а  именно в среде MS DOS, используя Turbo C 2.0. Hабор
системных  вызовов пока очень и очень невелик, но постоянно пополняется и сами
системные  вызовы  совершенствуются. Я приглашаю всех желающих поучаствовать в
написании  утилит для Пруликса или заняться адаптацией к Пруликсу существующих
программ.

        2. Программирование на С в Пруликсе

    Файл  hello.c  -  это  пример программы на С, написанной для Пруликса. Как
видите,  это  самая  обычная  С-программа, что и было моей целью - реализовать
самый  обычный  стандартный  С. Компиляция без Proolix headers невозможна, так
как стандартные хидеры из Turbo C не подходят. (Так, во всех системных вызовах
параметры  char  *  заменены  на  char  far  *).  Идеологией Пруликса является
совместимость  на  уровне  исходных  текстов  с MSDOS и UNIXом, а в идеале - с
любой  ОС  или  платформой, где есть компилятор С. Исходные тексты, написанные
для  Пруликса, будучи перекомпилированы в MSDOS или UNIXе, должны делать ТО ЖЕ
САМОЕ.

    Как  компилировать  С-программы для Пруликса. Если вы разбираетесь в make-
файлах, то все написано в файле makefile.

Файлы:

c1.obj - главный модуль С-программы, который вызывает функцию main() (в TurboC
эти  модули имеют имена вида c0<model>.obj, например c0t.obj для модели памяти
Tiny).  В  Пруликсе  (временно?)  все выполняемые программы имеют модель Tiny,
т.е.  занимают  максимум  1  сегмент  (64К). Обьединяя программы в конвейеры и
используя  распараллеливание (ни того ни другого пока не реализовано ;), можно
создавать   большие  программные  комплексы,  поэтому  необходимость  создания
выполнимых  файлов с виртуальным адресным пространством 1М представляется пока
сомнительной.

c1.asm - исходный текст модуля c1.obj

lib.lib - библиотека поддержки, содержащая заглушки для всех системных вызовов

000.asm и 001.asm - примеры двух первых заглушек

        3. Программирование на ассемблере в Пруликсе

    Слабость набора системных вызовов, реализованных на данный момент, требует
использования  программ,  написанных  на  ассемблере,  что, собственно говоря,
является некоторым отступлением от традиций UNIX, но что делать... Разумеется,
ассемблерные  утилиты  будут непереносимы на другие платформы, но без них пока
не обойтись.

    Файл  uasm.asm  -  это  пример  программы  на  ассемблере,  написанной для
Пруликса.  Обратите  внимание,  что  главная  программа  строится  в  виде far
процедуры  и  выход  из нее осуществляется командой ret far. (В com-файлах для
MSDOS  по умолчанию была бы near-процедура с ret near). Связано это с тем, что
вызов  выполняемого  модуля  производится  из ядра командой call far. C адреса
Signature  идет  5-байтовая  сигнатура,  по  которой  ядро Пруликса определяет
выполимый бинарный файл

(Кстати,  в  главном  модуле  для С - программе c1.asm сделано то же самое). В
файле  uasm  в  качестве  примера  моделируется системный вызов putch, как это
сделал бы компилятор TurboC, компилируя для Пруликса программу на С (например,
hello.c).  Полезно  откомпилировать  hello.c в ассемблерный модуль hello.asm и
сравнить с uasm.asm. Передача параметров системному вызову осуществляется так,
как   это   делает  компилятор  TurboC,  передавая  параметры  С-подпрограммам
(функциям)  через  стек  в  обратном порядке. Именно поэтому для компиляции С-
программ  нужен  только  TurboC  версии  2.0  (не ++ !), так как в ++ передача
параметров  может быть реализована по другому, а как на самом деле, я не знаю,
так  как  не  использовал  BC++  компиляторы.  Аналогичные проблемы касаются и
других (не борландовских) Скомпиляторов. Zortech или Watcom или HighC возможно
сделают  более  компактный  код,  но  как  там с параметрами??? Hе придется ли
переделывать всю логику системных вызовов?!

    Кроме  системных  вызовов,  в  ассемблерных  программах можно использовать
прерывания  ROM  BIOS  (int  10h,  int  16h  etc)  и  ячейки  памяти  ROM BIOS
(0040:XXXX).  Это  тоже  не  совсем по правилам, ведь по идее пользовательский
процесс  должен  осуществлять  системные  операции  и  ввод-вывод ТОЛЬКО через
системные вызовы, но никак не в обход ядра.

    Замечание.  Пруликс  работает  на  голой  машине, поэтому, разумеется ни о
каком int 21h не может быть и речи! Кроме того, нет файла ibmbio.com (io.sys),
который,   как   известно,  расширяет  некоторые  BIOS-прерывания.  Поэтому  я
подчеркиваю,  в  Пруликсе  можно  обращаться  не к функциям BIOS, а к функциям
именно  ROM  BIOS  -  т.е. именно к БИОСу, находящемуся в ПЗУ. Функции (или их
расширения, реализованные в ibmbio.com, естественно, будут недоступны.

        4. Адаптация программ на С для ОС Пруликс

    Простейший  случай  адаптации  программ,  написанных на языке С (и поэтому
претендующих  на переносимость) в другую ОС (в частности, Пруликс) заключается
в их перекомпиляции (сборке) в этой новой операционной среде. Как я уже писал,
компиляция   программ   для   Пруликса  производится  в  MSDOS  командой  make
компилятора TurboC или bat-файлом cc. Если вам повезет, то программа нормально
соберется  в  Пруликсе,  а  потом  может  быть  заработает. В противном случае
придется  искать  причину,  почему  же  программа не собирается и устранять ее
(причину), конечно, если она устранима.

    Как  определить,  что  данный системный вызов в Пруликсе еще не написан? В
этом  случае  у  вас  ошибка  проявится только на стадии редактирования связей
(линкования),  осуществляемого  программой  tlink.  После  обнаружения  списка
отсуствующих  системных  вызовов,  необходимо  свериться  с  документацией  по
Пруликсу,  где  должен  быть  приведен  список  реализованных  в данной версии
вызовов.  Затем  вы  можете  попытать обойтись без данного вызова, заменив его
чем-либо  другим,  параллельно  вам  стоит  обратиться  по электронной почте к
узлам, занимающимся поддержкой Пруликса за новой версией этой ОС, где возможно
будут реализованы новые возможности, в частности новые системные вызовы. Кроме
того,  надо  обратиться  к  автору Пруликса (ко мне) и я, возможно, оперативно
реализую необходимый вам системный вызов или помогу каким-либо другим образом.

    Что делать, если у вас нет такого старья, как TurboC, которым я пользуюсь?
Попробуйте   новые   продукты   фирмы   Борланд,  они  imho  должны  сохранять
преемственность  со  старыми.  Многие  решения  в реализации Прулиха, особенно
касающиеся интерфейса между машинно-зависимой частью, написанной на ассемблере
и  Сишной  частью,  обработки  прерываний,  передачи  параметров etc связаны с
реализацией всего этого в компиляторе (а именно в кодогенераторе) TurboC 2.0 и
если уже в TC++ 1.0 это сделано не так, то ничего у вас с новыми компиляторами
не получится. Я с интересом прочту сообщения о результатах сборки Пруликса под
компиляторами, отличными от моего ТС 2.0. Возможно, вам удастся уговорить меня
перейти  на другой компилятор. Но, как вы сами понимаете, это все паллиатив, и
рано или поздно придется в Пруликсе собирать свой cc (точнее, gcc ;)
