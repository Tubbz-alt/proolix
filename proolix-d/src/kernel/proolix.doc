        Операционная система Proolix - Документация

        1. История Пруликса

    ОС  Пруликс  начиналась  как  прикол  с  целью  приколоть  Игоря  Чунихина
(igor@ktts.kharkov.ua).  Затем  у меня возникла идиотская мысль, а не написать
ли  за  пару  месяцев  настоящую небольшую UNIX-подобную операционную систему?
Таким  образом, не имея опыта в написании ОС, я решил взяться за ЭТО. Hаписали
же T&K первый UNIX за несколько месяцев! Постепенно, по мере написания, передо
мной  вставали  все новые и новые трудности, и я понял, что это работа на годы
(тем  более, что я занимался пруликсом в свободное время и очень нерегулярно),
но задача меня увлекла и я бросать это не собираюсь.

        2. Идеология Пруликса

                                                Я увидел исходники ядра
                                                Пруликса и чуть не блеванул.
                                                        Приписывается
                                                        А.Деменьшину

    Перед  написанием  Пруликса  я  принял  ряд  стратегических идеологических
ошибок... то есть решений. Они заключаются в следующем:

        POSIX.  По  возможности  Пруликс  будет  POSIX-совместимым. В качестве
описания  стандарта  POSIX  я  использовал  любезно подаренную мне Г.Бочаровым
книгу Беляков М.И., Рабовер Ю.И., Фридман А.Л. Мобильная операционная система:
Справочник  -  М.:  Радио  и  связь, 19916 208 с. (в дальнейшем на эту книгу я
ссылаюсь вот так - [МОС])

        Мобильность.   При  написании  Пруликса  я  стараюсь  не  использовать
машинно-зависимых конструкций и поменьше писать на ассемблере (только там, где
без  этого  не  обойтись).  В  будущем,  возможно, я перенесу Пруликс на какую
нибудь другую машину из доступных мне (например, на домашнюю БК или Спектрум).
Связано   это   с   тем,   чтобы  сделать  себе  везде  одинаковую  среду  для
программирования  и работы - буду ли я на работе сидеть за консолью 486 или за
IP-терминалом,  буду  ли  дома  за  БК,  Спектрумом,  Поиском  или AT. Поэтому
многозадачные  возможности 386 процессора я не использую (да и не знаю их ;) и
Пруликс будет иметь только программную реализацию многозадачности, виртуальной
памяти и защиты (вследствие будет легко ломаться на уровне команд ассемблера)

        Turbo  C  2.0.  В  качестве инструментальной платформы (и справочного
средства  по  языку  С  ;)  я  использую TC 2.0. Я давно на нем работаю и уже
привык к нему, на Borland C++ переучиваться неохота, тем более, что я не знаю
обьектно  ориентированного  программирования.  В  новых версиях борландовских
продуктов  много  багов  и  глюков, а про ТС все говорят, что там менее всего
ошибок  и  он  самый UNIX- и ANSI-совместимый среди всех. А использовать что-
нибудь  крутое  (Watcom например), руки не доходят. Была, првда, мысль кросс-
компилять  под  UNIXом на gcc или взять gcc for DOS... Была еще мысль изучать
С++  и  начать писать обьектно-ориентированную ОС...

        Кросс-компиляция.  Собственный  компилятор cc или gcc в Пруликсе будет
очень  нескоро,  поэтому  программы  для  Пруликса  я  буду  компилировать под
MSDOS'ом  на  ТС  2.0.  (В  Пруликсе  будет  свой  ассемблер под названием pas
(Proolix ASsembler)).

        Совместимость  с  MS  DOS. Для отладки Пруликса создавать собственный
раздел  на  винчестере  imho  нецелесообразно,  поэтому  для  начала  я  буду
использовать файловую структуру MS DOS, немного расширив ее понятием связи ln
(chkdsk  и  ndd  на  вторые  ссылки  к файлам будут ругаться, но если файлы с
несколькими  связями  под  MSDOS'ом  только читать, а создавать и удалять под
Пруликсом, то imho глюков не будет, а chkdsk (fchk) в Пруликсе я напишу свой)
и  используя  неиспользуемые  поля  записи  в  каталоге для хранения UNIXовых
параметров  файла (код владельца, права доступа, продолжение имени - примерно
так файловая система OS/2 расширяет файловую систему МС ДОСа).

        BIOS.  Осознавая трудности и громоздкость задачи написания ОС, я решил
максимально  воспользоваться  готовыми  разработками.  Так, драйверы устройств
ввода-вывода  (клавиатура,  дисплей,  флоп,  винт)  я  не  буду писать, а буду
использовать  вызовы  ROM BIOS. Тут появятся проблемы с нереентерабельностью и
"однозадачностью"  BIOS,  но  их  imho  можно решить, организовав коллективный
доступ  к такому ресурсу как BIOS так, чтобы например, не было одновренменно в
двух  процессах  открытого  int  13h.
